{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "navbar",
  "type": "registry:ui",
  "title": "导航栏",
  "description": "导航栏组件，用于导航等元素的导航栏",
  "dependencies": [
    "@react-stately/toggle",
    "@react-aria/overlays",
    "@react-stately/utils"
  ],
  "registryDependencies": [
    "@tcsk/button"
  ],
  "files": [
    {
      "path": "registry/ui/navbar/index.ts",
      "content": "// export types\nexport type { NavbarProps } from \"./navbar\";\nexport type { NavbarBrandProps } from \"./navbar-brand\";\nexport type { NavbarContentProps } from \"./navbar-content\";\nexport type { NavbarItemProps } from \"./navbar-item\";\nexport type { NavbarMenuToggleProps } from \"./navbar-menu-toggle\";\nexport type { NavbarMenuProps } from \"./navbar-menu\";\nexport type { NavbarMenuItemProps } from \"./navbar-menu-item\";\n\n// export hooks\nexport { useNavbar } from \"./use-navbar\";\n\n// export context\nexport { NavbarProvider, useNavbarContext } from \"./navbar-context\";\n\n// export components\nexport { default as Navbar } from \"./navbar\";\nexport { default as NavbarBrand } from \"./navbar-brand\";\nexport { default as NavbarContent } from \"./navbar-content\";\nexport { default as NavbarItem } from \"./navbar-item\";\nexport { default as NavbarMenuToggle } from \"./navbar-menu-toggle\";\nexport { default as NavbarMenu } from \"./navbar-menu\";\nexport { default as NavbarMenuItem } from \"./navbar-menu-item\";\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-brand.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\n\nimport { useNavbarContext } from \"./navbar-context\";\n\nimport { clsx } from \"@/lib/base\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { forwardRef } from \"@/lib/system\";\n\nexport interface NavbarBrandProps extends HTMLHeroUIProps<\"div\"> {\n  children?: React.ReactNode | React.ReactNode[];\n}\n\nconst NavbarBrand = forwardRef<\"div\", NavbarBrandProps>((props, ref) => {\n  const { as, className, children, ...otherProps } = props;\n\n  const Component = as || \"div\";\n  const domRef = useDOMRef(ref);\n\n  const { slots, classNames } = useNavbarContext();\n\n  const styles = clsx(classNames?.brand, className);\n\n  return (\n    <Component ref={domRef} className={slots.brand?.({ class: styles })} {...otherProps}>\n      {children}\n    </Component>\n  );\n});\n\nNavbarBrand.displayName = \"HeroUI.NavbarBrand\";\n\nexport default NavbarBrand;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-content.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\n\nimport { useNavbarContext } from \"./navbar-context\";\n\nimport { clsx } from \"@/lib/base\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { forwardRef } from \"@/lib/system\";\n\nexport interface NavbarContentProps extends HTMLHeroUIProps<\"ul\"> {\n  /**\n   * The content of the Navbar.Content. It is usually the `NavbarItem`,\n   */\n  children?: React.ReactNode | React.ReactNode[];\n  /**\n   * The justify of the content\n   * @default start\n   */\n  justify?: \"start\" | \"end\" | \"center\";\n}\n\nconst NavbarContent = forwardRef<\"ul\", NavbarContentProps>((props, ref) => {\n  const { as, className, children, justify = \"start\", ...otherProps } = props;\n\n  const Component = as || \"ul\";\n  const domRef = useDOMRef(ref);\n\n  const { slots, classNames } = useNavbarContext();\n\n  const styles = clsx(classNames?.content, className);\n\n  return (\n    <Component ref={domRef} className={slots.content?.({ class: styles })} data-justify={justify} {...otherProps}>\n      {children}\n    </Component>\n  );\n});\n\nNavbarContent.displayName = \"HeroUI.NavbarContent\";\n\nexport default NavbarContent;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-context.ts",
      "content": "import type { UseNavbarReturn } from \"./use-navbar\";\n\nimport { createContext } from \"@/lib/react/context\";\n\nexport const [NavbarProvider, useNavbarContext] = createContext<UseNavbarReturn>({\n  name: \"NavbarContext\",\n  strict: true,\n  errorMessage: \"useNavbarContext: `context` is undefined. Seems you forgot to wrap component within <Navbar />\",\n});\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-item.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\n\nimport { useNavbarContext } from \"./navbar-context\";\n\nimport { clsx, dataAttr } from \"@/lib/base\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { forwardRef } from \"@/lib/system\";\n\nexport interface NavbarItemProps extends HTMLHeroUIProps<\"li\"> {\n  children?: React.ReactNode;\n  /**\n   * Whether the item is active or not.\n   * @default false\n   */\n  isActive?: boolean;\n}\n\nconst NavbarItem = forwardRef<\"li\", NavbarItemProps>((props, ref) => {\n  const { as, className, children, isActive, ...otherProps } = props;\n\n  const Component = as || \"li\";\n  const domRef = useDOMRef(ref);\n\n  const { slots, classNames } = useNavbarContext();\n\n  const styles = clsx(classNames?.item, className);\n\n  return (\n    <Component\n      ref={domRef}\n      className={slots.item?.({ class: styles })}\n      data-active={dataAttr(isActive)}\n      {...otherProps}\n    >\n      {children}\n    </Component>\n  );\n});\n\nNavbarItem.displayName = \"HeroUI.NavbarItem\";\n\nexport default NavbarItem;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-menu-item.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\n\nimport { useNavbarContext } from \"./navbar-context\";\n\nimport { clsx, dataAttr } from \"@/lib/base\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { forwardRef } from \"@/lib/system\";\n\nexport interface NavbarMenuItemProps extends HTMLHeroUIProps<\"li\"> {\n  /**\n   * Whether the item is active or not.\n   * @default false\n   */\n  isActive?: boolean;\n  children?: React.ReactNode;\n}\n\nconst NavbarMenuItem = forwardRef<\"li\", NavbarMenuItemProps>((props, ref) => {\n  const { className, children, isActive, ...otherProps } = props;\n\n  const domRef = useDOMRef(ref);\n\n  const { slots, isMenuOpen, classNames } = useNavbarContext();\n\n  const styles = clsx(classNames?.menuItem, className);\n\n  return (\n    <li\n      ref={domRef}\n      className={slots.menuItem?.({ class: styles })}\n      data-active={dataAttr(isActive)}\n      data-open={dataAttr(isMenuOpen)}\n      {...otherProps}\n    >\n      {children}\n    </li>\n  );\n});\n\nNavbarMenuItem.displayName = \"HeroUI.NavbarMenuItem\";\n\nexport default NavbarMenuItem;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-menu-toggle.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\nimport type { AriaToggleButtonProps } from \"@react-aria/button\";\nimport type { ReactNode } from \"react\";\n\nimport { useToggleButton as useAriaToggleButton } from \"@react-aria/button\";\nimport { useFocusRing } from \"@react-aria/focus\";\nimport { useHover } from \"@react-aria/interactions\";\nimport { useToggleState } from \"@react-stately/toggle\";\nimport { useMemo } from \"react\";\n\nimport { useNavbarContext } from \"./navbar-context\";\n\nimport { forwardRef } from \"@/lib/system\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { clsx, dataAttr, mergeProps } from \"@/lib/base\";\n\nexport interface Props extends Omit<HTMLHeroUIProps<\"button\">, keyof AriaToggleButtonProps> {\n  /**\n   * The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue).\n   */\n  value?: string;\n  /**\n   * Text to display for screen readers.\n   * @default open/close navigation menu\n   */\n  srOnlyText?: string;\n  /**\n   * The icon to display.\n   */\n  icon?: ReactNode | ((isOpen: boolean) => ReactNode) | null;\n}\n\nexport type NavbarMenuToggleProps = Props & AriaToggleButtonProps;\n\nconst NavbarMenuToggle = forwardRef<\"button\", NavbarMenuToggleProps>((props, ref) => {\n  const { as, icon, className, onChange, autoFocus, srOnlyText: srOnlyTextProp, ...otherProps } = props;\n\n  const Component = as || \"button\";\n  const domRef = useDOMRef(ref);\n\n  const { slots, classNames, isMenuOpen, setIsMenuOpen } = useNavbarContext();\n\n  const handleChange = (isOpen: boolean) => {\n    onChange?.(isOpen);\n    setIsMenuOpen(isOpen);\n  };\n\n  const state = useToggleState({ ...otherProps, isSelected: isMenuOpen, onChange: handleChange });\n\n  const { buttonProps, isPressed } = useAriaToggleButton(props, state, domRef);\n  const { isFocusVisible, focusProps } = useFocusRing({ autoFocus });\n  const { isHovered, hoverProps } = useHover({});\n\n  const toggleStyles = clsx(classNames?.toggle, className);\n\n  const child = useMemo(() => {\n    if (typeof icon === \"function\") {\n      return icon(isMenuOpen ?? false);\n    }\n\n    return icon || <span className={slots.toggleIcon({ class: classNames?.toggleIcon })} />;\n  }, [icon, isMenuOpen, slots.toggleIcon, classNames?.toggleIcon]);\n\n  const srOnlyText = useMemo(() => {\n    if (srOnlyTextProp) {\n      return srOnlyTextProp;\n    }\n\n    return state.isSelected ? \"close navigation menu\" : \"open navigation menu\";\n  }, [srOnlyTextProp, isMenuOpen]);\n\n  return (\n    <Component\n      ref={domRef}\n      className={slots.toggle?.({ class: toggleStyles })}\n      data-focus-visible={dataAttr(isFocusVisible)}\n      data-hover={dataAttr(isHovered)}\n      data-open={dataAttr(isMenuOpen)}\n      data-pressed={dataAttr(isPressed)}\n      {...mergeProps(buttonProps, focusProps, hoverProps, otherProps)}\n    >\n      <span className={slots.srOnly()}>{srOnlyText}</span>\n      {child}\n    </Component>\n  );\n});\n\nNavbarMenuToggle.displayName = \"HeroUI.NavbarMenuToggle\";\n\nexport default NavbarMenuToggle;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-menu-transitions.ts",
      "content": "import type { Variants } from \"framer-motion\";\n\nexport const menuVariants: Variants = {\n  enter: {\n    height: \"calc(100vh - var(--navbar-height))\",\n    transition: {\n      duration: 0.3,\n      easings: \"easeOut\",\n    },\n  },\n  exit: {\n    height: 0,\n    transition: {\n      duration: 0.25,\n      easings: \"easeIn\",\n    },\n  },\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-menu.tsx",
      "content": "import type { HTMLHeroUIProps } from \"@/lib/system\";\nimport type { HTMLMotionProps } from \"framer-motion\";\n\nimport { Overlay } from \"@react-aria/overlays\";\nimport { AnimatePresence, LazyMotion, m } from \"framer-motion\";\nimport React from \"react\";\n\nimport { useNavbarContext } from \"./navbar-context\";\nimport { menuVariants } from \"./navbar-menu-transitions\";\n\nimport { forwardRef } from \"@/lib/system\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { clsx, dataAttr, mergeProps } from \"@/lib/base\";\n\nexport interface NavbarMenuProps extends HTMLHeroUIProps<\"ul\"> {\n  children?: React.ReactNode;\n  /**\n   * The container element in which the navbar menu overlay portal will be placed.\n   * @default document.body\n   */\n  portalContainer?: Element;\n  /**\n   * The props to modify the framer motion animation. Use the `variants` API to create your own animation.\n   */\n  motionProps?: Omit<HTMLMotionProps<\"ul\">, \"ref\">;\n}\n\nconst domAnimation = () => import(\"@/lib/dom-animation\").then((res) => res.default);\n\nconst NavbarMenu = forwardRef<\"ul\", NavbarMenuProps>((props, ref) => {\n  const { className, children, portalContainer, motionProps, style, ...otherProps } = props;\n  const domRef = useDOMRef(ref);\n\n  const { slots, isMenuOpen, height, disableAnimation, classNames } = useNavbarContext();\n\n  const styles = clsx(classNames?.menu, className);\n\n  if (disableAnimation) {\n    if (!isMenuOpen) return null;\n\n    return (\n      <Overlay portalContainer={portalContainer}>\n        <ul\n          ref={domRef}\n          className={slots.menu?.({ class: styles })}\n          data-open={dataAttr(isMenuOpen)}\n          style={{\n            // @ts-expect-error\n            \"--navbar-height\": typeof height === \"number\" ? `${height}px` : height,\n          }}\n          {...otherProps}\n        >\n          {children}\n        </ul>\n      </Overlay>\n    );\n  }\n\n  return (\n    <AnimatePresence mode=\"wait\">\n      {isMenuOpen ? (\n        <Overlay portalContainer={portalContainer}>\n          <LazyMotion features={domAnimation}>\n            <m.ul\n              ref={domRef}\n              layoutScroll\n              animate=\"enter\"\n              className={slots.menu?.({ class: styles })}\n              data-open={dataAttr(isMenuOpen)}\n              exit=\"exit\"\n              initial=\"exit\"\n              style={{\n                // @ts-expect-error\n                \"--navbar-height\": typeof height === \"number\" ? `${height}px` : height,\n                ...style,\n              }}\n              variants={menuVariants}\n              {...mergeProps(motionProps, otherProps)}\n            >\n              {children}\n            </m.ul>\n          </LazyMotion>\n        </Overlay>\n      ) : null}\n    </AnimatePresence>\n  );\n});\n\nNavbarMenu.displayName = \"HeroUI.NavbarMenu\";\n\nexport default NavbarMenu;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar-transitions.ts",
      "content": "import type { Variants } from \"framer-motion\";\n\nimport { TRANSITION_EASINGS } from \"@/lib/framer\";\n\nexport const hideOnScrollVariants: Variants = {\n  visible: {\n    y: 0,\n    transition: {\n      ease: TRANSITION_EASINGS.easeOut,\n    },\n  },\n  hidden: {\n    y: \"-100%\",\n    transition: {\n      ease: TRANSITION_EASINGS.easeIn,\n    },\n  },\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/navbar.tsx",
      "content": "import type { UseNavbarProps } from \"./use-navbar\";\n\nimport { LazyMotion, m } from \"framer-motion\";\n\nimport { NavbarProvider } from \"./navbar-context\";\nimport NavbarMenu from \"./navbar-menu\";\nimport { hideOnScrollVariants } from \"./navbar-transitions\";\nimport { useNavbar } from \"./use-navbar\";\n\nimport { mergeProps } from \"@/lib/base\";\nimport { pickChildren } from \"@/lib/react-rsc/children\";\nimport { forwardRef } from \"@/lib/system\";\n\nexport interface NavbarProps extends Omit<UseNavbarProps, \"hideOnScroll\"> {\n  children?: React.ReactNode | React.ReactNode[];\n}\n\nconst domAnimation = () => import(\"@/lib/dom-animation\").then((res) => res.default);\n\nconst Navbar = forwardRef<\"div\", NavbarProps>((props, ref) => {\n  const { children, ...otherProps } = props;\n\n  const context = useNavbar({ ...otherProps, ref });\n\n  const Component = context.Component;\n\n  const [childrenWithoutMenu, menu] = pickChildren(children, NavbarMenu);\n\n  const content = (\n    <>\n      <header {...context.getWrapperProps()}>{childrenWithoutMenu}</header>\n      {menu}\n    </>\n  );\n\n  return (\n    <NavbarProvider value={context}>\n      {context.shouldHideOnScroll ? (\n        <LazyMotion features={domAnimation}>\n          <m.nav\n            animate={context.isHidden ? \"hidden\" : \"visible\"}\n            initial={false}\n            variants={hideOnScrollVariants}\n            {...mergeProps(context.getBaseProps(), context.motionProps)}\n          >\n            {content}\n          </m.nav>\n        </LazyMotion>\n      ) : (\n        <Component {...context.getBaseProps()}>{content}</Component>\n      )}\n    </NavbarProvider>\n  );\n});\n\nNavbar.displayName = \"HeroUI.Navbar\";\n\nexport default Navbar;\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/theme.ts",
      "content": "import type { VariantProps } from \"tailwind-variants\";\n\nimport { dataFocusVisibleClasses } from \"@/lib/theme/utils/classes\";\nimport { tv } from \"@/lib/theme/utils/tv\";\n\n/**\n * Card **Tailwind Variants** component\n *\n * @example\n * ```js\n * const {\n *  base,\n *  wrapper,\n *  toggle,\n *  srOnly,\n *  toggleIcon,\n *  brand,\n *  content,\n *  item,\n *  menu,\n *  menuItem\n * } = navbar({...})\n *\n * <nav className={base()} style={{ \"--navbar-height\": \"4rem\" }}>\n *    <header className={wrapper()}>\n *      <button className={toggle()}>\n *        <span className={srOnly()}>Open/Close menu</span>\n *        <span className={toggleIcon()} aria-hidden=\"true\"/>\n *      </button>\n *      <div className={brand()}>Brand</div>\n *      <ul className={content()}>\n *        <li className={item()}>Item 1</li>\n *        <li className={item()}>Item 2</li>\n *        <li className={item()}>Item 3</li>\n *      </ul>\n *      <ul className={content()}>\n *        <li className={item()}>Login</li>\n *        <li className={item()}>Sign Up</li>\n *      </ul>\n *    </header>\n *    <ul className={menu()}>\n *      <li className={menuItem()}>Item 1</li>\n *      <li className={menuItem()}>Item 2</li>\n *      <li className={menuItem()}>Item 3</li>\n *   </ul>\n * </nav>\n * ```\n */\nconst navbar = tv({\n  slots: {\n    base: [\"flex\", \"z-40\", \"w-full\", \"h-auto\", \"items-center\", \"justify-center\", \"data-[menu-open=true]:border-none\"],\n    wrapper: [\n      \"z-40\",\n      \"flex\",\n      \"px-6\",\n      \"gap-4\",\n      \"w-full\",\n      \"flex-row\",\n      \"relative\",\n      \"flex-nowrap\",\n      \"items-center\",\n      \"justify-between\",\n      \"h-[var(--navbar-height)]\",\n    ],\n    toggle: [\n      \"group\",\n      \"flex\",\n      \"items-center\",\n      \"justify-center\",\n      \"w-6\",\n      \"h-full\",\n      \"outline-solid outline-transparent\",\n      \"rounded-small\",\n      \"tap-highlight-transparent\",\n      // focus ring\n      ...dataFocusVisibleClasses,\n    ],\n    srOnly: [\"sr-only\"],\n    toggleIcon: [\n      \"w-full\",\n      \"h-full\",\n      \"pointer-events-none\",\n      \"flex\",\n      \"flex-col\",\n      \"items-center\",\n      \"justify-center\",\n      \"text-inherit\",\n      \"group-data-[pressed=true]:opacity-70\",\n      \"transition-opacity\",\n      // before - first line\n      \"before:content-['']\",\n      \"before:block\",\n      \"before:h-px\",\n      \"before:w-6\",\n      \"before:bg-current\",\n      \"before:transition-transform\",\n      \"before:duration-150\",\n      \"before:-translate-y-1\",\n      \"before:rotate-0\",\n      \"group-data-[open=true]:before:translate-y-px\",\n      \"group-data-[open=true]:before:rotate-45\",\n      // after - second line\n      \"after:content-['']\",\n      \"after:block\",\n      \"after:h-px\",\n      \"after:w-6\",\n      \"after:bg-current\",\n      \"after:transition-transform\",\n      \"after:duration-150\",\n      \"after:translate-y-1\",\n      \"after:rotate-0\",\n      \"group-data-[open=true]:after:translate-y-0\",\n      \"group-data-[open=true]:after:-rotate-45\",\n    ],\n    brand: [\n      \"flex\",\n      \"basis-0\",\n      \"flex-row\",\n      \"flex-grow\",\n      \"flex-nowrap\",\n      \"justify-start\",\n      \"bg-transparent\",\n      \"items-center\",\n      \"no-underline\",\n      \"text-medium\",\n      \"whitespace-nowrap\",\n      \"box-border\",\n    ],\n    content: [\n      \"flex\",\n      \"gap-4\",\n      \"h-full\",\n      \"flex-row\",\n      \"flex-nowrap\",\n      \"items-center\",\n      \"data-[justify=start]:justify-start\",\n      \"data-[justify=start]:flex-grow\",\n      \"data-[justify=start]:basis-0\",\n      \"data-[justify=center]:justify-center\",\n      \"data-[justify=end]:justify-end\",\n      \"data-[justify=end]:flex-grow\",\n      \"data-[justify=end]:basis-0\",\n    ],\n    item: [\n      \"text-medium\",\n      \"whitespace-nowrap\",\n      \"box-border\",\n      \"list-none\",\n      // active\n      \"data-[active=true]:font-semibold\",\n    ],\n    menu: [\n      \"z-30\",\n      \"px-6\",\n      \"pt-2\",\n      \"fixed\",\n      \"flex\",\n      \"max-w-full\",\n      \"top-[var(--navbar-height)]\",\n      \"inset-x-0\",\n      \"bottom-0\",\n      \"w-screen\",\n      \"flex-col\",\n      \"gap-2\",\n      \"overflow-y-auto\",\n    ],\n    menuItem: [\n      \"text-large\", // active\n      \"data-[active=true]:font-semibold\",\n    ],\n  },\n  variants: {\n    position: {\n      static: {\n        base: \"static\",\n      },\n      sticky: {\n        base: \"sticky top-0 inset-x-0\",\n      },\n    },\n    maxWidth: {\n      sm: {\n        wrapper: \"max-w-[640px]\",\n      },\n      md: {\n        wrapper: \"max-w-[768px]\",\n      },\n      lg: {\n        wrapper: \"max-w-[1024px]\",\n      },\n      xl: {\n        wrapper: \"max-w-[1280px]\",\n      },\n      \"2xl\": {\n        wrapper: \"max-w-[1536px]\",\n      },\n      full: {\n        wrapper: \"max-w-full\",\n      },\n    },\n    hideOnScroll: {\n      true: {\n        base: [\"sticky\", \"top-0\", \"inset-x-0\"],\n      },\n    },\n    isBordered: {\n      true: {\n        base: [\"border-b\", \"border-divider\"],\n      },\n    },\n    isBlurred: {\n      false: {\n        base: \"bg-background\",\n        menu: \"bg-background\",\n      },\n      true: {\n        base: [\n          \"backdrop-blur-lg\",\n          \"data-[menu-open=true]:backdrop-blur-xl\",\n          \"backdrop-saturate-150\",\n          \"bg-background/70\",\n        ],\n        menu: [\"backdrop-blur-xl\", \"backdrop-saturate-150\", \"bg-background/70\"],\n      },\n    },\n    disableAnimation: {\n      true: {\n        menu: [\"hidden\", \"h-[calc(100dvh_-_var(--navbar-height))]\", \"data-[open=true]:flex\"],\n      },\n    },\n  },\n  defaultVariants: {\n    maxWidth: \"lg\",\n    position: \"sticky\",\n    isBlurred: true,\n  },\n});\n\nexport type NavbarVariantProps = VariantProps<typeof navbar>;\nexport type NavbarSlots = keyof ReturnType<typeof navbar>;\n\nexport { navbar };\n",
      "type": "registry:ui"
    },
    {
      "path": "registry/ui/navbar/use-navbar.ts",
      "content": "import type { ReactRef } from \"@/lib/react\";\nimport type { HTMLHeroUIProps, PropGetter } from \"@/lib/system\";\nimport type { SlotsToClasses } from \"@/lib/theme/utils/types\";\nimport type { HTMLMotionProps } from \"framer-motion\";\nimport type { NavbarSlots, NavbarVariantProps } from \"./theme\";\n\nimport { usePreventScroll } from \"@react-aria/overlays\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { navbar } from \"./theme\";\n\nimport { useResizeObserver } from \"@/hooks/use-resize\";\nimport { useScrollPosition } from \"@/hooks/use-scroll-position\";\nimport { clsx, dataAttr, mergeProps, objectToDeps } from \"@/lib/base\";\nimport { useDOMRef } from \"@/lib/react\";\nimport { mapPropsVariants, useProviderContext } from \"@/lib/system\";\n\ninterface Props extends HTMLHeroUIProps<\"nav\"> {\n  /**\n   * Ref to the DOM node.\n   */\n  ref?: ReactRef<HTMLElement | null>;\n  /**\n   * The parent element where the navbar is placed within.\n   * This is used to determine the scroll position and whether the navbar should be hidden or not.\n   * @default `window`\n   */\n  parentRef?: React.RefObject<HTMLElement>;\n  /**\n   * The height of the navbar.\n   * @default \"4rem\" (64px)\n   */\n  height?: number | string;\n  /**\n   * Whether the menu is open.\n   * @default false\n   */\n  isMenuOpen?: boolean;\n  /**\n   * Whether the menu should be open by default.\n   * @default false\n   */\n  isMenuDefaultOpen?: boolean;\n  /**\n   * Whether the navbar should hide on scroll or not.\n   * @default false\n   */\n  shouldHideOnScroll?: boolean;\n  /**\n   * Whether the navbar should block scroll when the menu is open or not.\n   * @default false\n   */\n  shouldBlockScroll?: boolean;\n  /**\n   * Whether the navbar parent scroll event should be listened to or not.\n   * @default false\n   */\n  disableScrollHandler?: boolean;\n  /**\n   * The props to modify the framer motion animation. Use the `variants` API to create your own animation.\n   * This motion is only available if the `shouldHideOnScroll` prop is set to `true`.\n   */\n  motionProps?: Omit<HTMLMotionProps<\"nav\">, \"ref\">;\n  /**\n   * The event handler for the menu open state.\n   * @param isOpen boolean\n   * @returns void\n   */\n  onMenuOpenChange?: (isOpen: boolean) => void;\n  /**\n   * The scroll event handler for the navbar. The event fires when the navbar parent element is scrolled.\n   * it only works if `disableScrollHandler` is set to `false` or `shouldHideOnScroll` is set to `true`.\n   */\n  onScrollPositionChange?: (scrollPosition: number) => void;\n  /**\n   * Classname or List of classes to change the classNames of the element.\n   * if `className` is passed, it will be added to the base slot.\n   *\n   * @example\n   * ```ts\n   * <Navbar classNames={{\n   *    base:\"base-classes\",\n   *    wrapper: \"wrapper-classes\",\n   *    brand: \"brand-classes\",\n   *    content: \"content-classes\",\n   *    item: \"item-classes\",\n   *    menu: \"menu-classes\", // the one that appears when the menu is open\n   *    menuItem: \"menu-item-classes\",\n   * }} />\n   * ```\n   */\n  classNames?: SlotsToClasses<NavbarSlots>;\n}\n\nexport type UseNavbarProps = Props & NavbarVariantProps;\n\nexport function useNavbar(originalProps: UseNavbarProps) {\n  const globalContext = useProviderContext();\n\n  const [props, variantProps] = mapPropsVariants(originalProps, navbar.variantKeys);\n\n  const {\n    ref,\n    as,\n    parentRef,\n    height = \"4rem\",\n    shouldHideOnScroll = false,\n    disableScrollHandler = false,\n    shouldBlockScroll = true,\n    onScrollPositionChange,\n    isMenuOpen: isMenuOpenProp,\n    isMenuDefaultOpen,\n    onMenuOpenChange = () => {},\n    motionProps,\n    className,\n    classNames,\n    ...otherProps\n  } = props;\n\n  const Component = as || \"nav\";\n  const disableAnimation = originalProps.disableAnimation ?? globalContext?.disableAnimation ?? false;\n\n  const domRef = useDOMRef(ref);\n\n  const prevWidth = useRef(0);\n  const navHeight = useRef(0);\n\n  const [isHidden, setIsHidden] = useState(false);\n\n  const handleMenuOpenChange = useCallback(\n    (isOpen: boolean | undefined) => {\n      onMenuOpenChange(isOpen || false);\n    },\n    [onMenuOpenChange],\n  );\n\n  const [isMenuOpen, setIsMenuOpen] = useControlledState<boolean>(\n    isMenuOpenProp,\n    isMenuDefaultOpen ?? false,\n    handleMenuOpenChange,\n  );\n\n  const updateWidth = () => {\n    if (domRef.current) {\n      const width = domRef.current.offsetWidth;\n\n      if (width !== prevWidth.current) {\n        prevWidth.current = width;\n      }\n    }\n  };\n\n  usePreventScroll({\n    isDisabled: !(shouldBlockScroll && isMenuOpen),\n  });\n\n  useResizeObserver({\n    ref: domRef,\n    onResize: () => {\n      const currentWidth = domRef.current?.offsetWidth;\n      const scrollWidth = window.innerWidth - document.documentElement.clientWidth;\n\n      if (currentWidth && currentWidth + scrollWidth == prevWidth.current) {\n        return;\n      }\n\n      if (currentWidth !== prevWidth.current) {\n        updateWidth();\n        setIsMenuOpen(false);\n      }\n    },\n  });\n\n  useEffect(() => {\n    updateWidth();\n\n    navHeight.current = domRef.current?.offsetHeight || 0;\n  }, []);\n\n  const slots = useMemo(\n    () =>\n      navbar({\n        ...variantProps,\n        disableAnimation,\n        hideOnScroll: shouldHideOnScroll,\n      }),\n    [objectToDeps(variantProps), disableAnimation, shouldHideOnScroll],\n  );\n\n  const baseStyles = clsx(classNames?.base, className);\n\n  useScrollPosition({\n    elementRef: parentRef,\n    isEnabled: shouldHideOnScroll || !disableScrollHandler,\n    callback: ({ prevPos, currPos }) => {\n      onScrollPositionChange?.(currPos.y);\n      if (shouldHideOnScroll) {\n        setIsHidden((prev) => {\n          const next = currPos.y > prevPos.y && currPos.y > navHeight.current;\n\n          return next !== prev ? next : prev;\n        });\n      }\n    },\n  });\n\n  const getBaseProps: PropGetter = (props = {}) => ({\n    ...mergeProps(otherProps, props),\n    \"data-hidden\": dataAttr(isHidden),\n    \"data-menu-open\": dataAttr(isMenuOpen),\n    ref: domRef,\n    className: slots.base({ class: clsx(baseStyles, props?.className) }),\n    style: {\n      \"--navbar-height\": typeof height === \"number\" ? `${height}px` : height,\n      ...otherProps?.style,\n      ...props?.style,\n    },\n  });\n\n  const getWrapperProps: PropGetter = (props = {}) => ({\n    ...props,\n    \"data-menu-open\": dataAttr(isMenuOpen),\n    className: slots.wrapper({ class: clsx(classNames?.wrapper, props?.className) }),\n  });\n\n  return {\n    Component,\n    slots,\n    domRef,\n    height,\n    isHidden,\n    disableAnimation,\n    shouldHideOnScroll,\n    isMenuOpen,\n    classNames,\n    setIsMenuOpen,\n    motionProps,\n    getBaseProps,\n    getWrapperProps,\n  };\n}\n\nexport type UseNavbarReturn = ReturnType<typeof useNavbar>;\n",
      "type": "registry:ui"
    },
    {
      "path": "lib/framer/index.ts",
      "content": "export type { TransitionConfig, TransitionEndConfig, TransitionProperties, Variants } from \"./transition-utils\";\n\nexport { TRANSITION_DEFAULTS, TRANSITION_EASINGS, TRANSITION_VARIANTS } from \"./transition-utils\";\n\nexport { ResizablePanel } from \"./resizable-panel\";\nexport type { ResizablePanelProps } from \"./resizable-panel\";\n",
      "type": "registry:lib"
    },
    {
      "path": "hooks/use-resize/index.ts",
      "content": "import { useEffect } from \"react\";\n\ninterface RefObject<T> {\n  current: T;\n}\n\nexport function useResize(callback: Function, immediatelyInvoke: boolean = true) {\n  useEffect(() => {\n    const fn = () => callback();\n\n    if (immediatelyInvoke) {\n      fn();\n    }\n    window.addEventListener(\"resize\", fn);\n\n    return () => window.removeEventListener(\"resize\", fn);\n  }, []);\n}\n\nfunction hasResizeObserver() {\n  return typeof window.ResizeObserver !== \"undefined\";\n}\n\ntype useResizeObserverOptionsType<T> = {\n  ref: RefObject<T | undefined | null> | undefined;\n  box?: ResizeObserverBoxOptions;\n  onResize: () => void;\n};\n\nexport function useResizeObserver<T extends Element>(options: useResizeObserverOptionsType<T>): void {\n  const { ref, box, onResize } = options;\n\n  useEffect(() => {\n    let element = ref?.current;\n\n    if (!element) {\n      return;\n    }\n\n    if (!hasResizeObserver()) {\n      window.addEventListener(\"resize\", onResize, false);\n\n      return () => {\n        window.removeEventListener(\"resize\", onResize, false);\n      };\n    } else {\n      const resizeObserverInstance = new window.ResizeObserver((entries) => {\n        if (!entries.length) {\n          return;\n        }\n\n        onResize();\n      });\n\n      resizeObserverInstance.observe(element, { box });\n\n      return () => {\n        if (element) {\n          resizeObserverInstance.unobserve(element);\n        }\n      };\n    }\n  }, [onResize, ref, box]);\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "hooks/use-scroll-position/index.ts",
      "content": "import { useCallback, useEffect, useRef } from \"react\";\n\nconst isBrowser = typeof window !== \"undefined\";\n\nexport type ScrollValue = { x: number; y: number };\n\nfunction getScrollPosition(element: HTMLElement | undefined | null): ScrollValue {\n  if (!isBrowser) return { x: 0, y: 0 };\n  if (!element) {\n    return { x: window.scrollX, y: window.scrollY };\n  }\n\n  return { x: element.scrollLeft, y: element.scrollTop };\n}\n\nexport interface UseScrollPositionOptions {\n  /**\n   * The wait time in milliseconds before triggering the callback.\n   * @default 30\n   */\n  delay?: number;\n  /**\n   * Whether the scroll position should be tracked or not.\n   * @default true\n   */\n  isEnabled?: boolean;\n  /**\n   * The element to track the scroll position for.\n   */\n  elementRef?: React.RefObject<HTMLElement> | null;\n  /**\n   * The callback function to be called when the scroll position changes.\n   */\n  callback?: ({ prevPos, currPos }: { prevPos: ScrollValue; currPos: ScrollValue }) => void;\n}\n\nexport const useScrollPosition = (props: UseScrollPositionOptions): ScrollValue => {\n  const { elementRef, delay = 30, callback, isEnabled } = props;\n\n  const position = useRef<ScrollValue>(isEnabled ? getScrollPosition(elementRef?.current) : { x: 0, y: 0 });\n\n  const throttleTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const handler = useCallback(() => {\n    const currPos = getScrollPosition(elementRef?.current);\n\n    if (typeof callback === \"function\") {\n      callback({ prevPos: position.current, currPos });\n    }\n\n    position.current = currPos;\n    throttleTimeout.current = null;\n  }, [callback, elementRef]);\n\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    const handleScroll = () => {\n      if (delay) {\n        if (throttleTimeout.current) {\n          clearTimeout(throttleTimeout.current);\n        }\n\n        throttleTimeout.current = setTimeout(handler, delay);\n      } else {\n        handler();\n      }\n    };\n\n    const target = elementRef?.current || window;\n\n    target.addEventListener(\"scroll\", handleScroll);\n\n    return () => {\n      target.removeEventListener(\"scroll\", handleScroll);\n      if (throttleTimeout.current) {\n        clearTimeout(throttleTimeout.current);\n        throttleTimeout.current = null;\n      }\n    };\n  }, [elementRef?.current, delay, handler, isEnabled]);\n\n  return position.current;\n};\n",
      "type": "registry:hook"
    }
  ]
}